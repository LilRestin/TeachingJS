// result = a || b ИЛИ


// let hour = 9;
// if (hour < 10 || hour > 18)
// {
//     alert('Офис закрыт')
// }


// let hour = 12;
// let isWeekend = true;

// if (hour < 10 || hour > 18 || isWeekend) {
//   alert( 'Офис закрыт.' ); 
// }


// alert( 1 || 0 ); // 1
// alert( true || 'no matter what' ); // true

// alert( null || 1 ); // 1 (первое истинное значение)
// alert( null || 0 || 1 ); // 1 (первое истинное значение)
// alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)


// let x;
// true || (x = 1);
// alert(x); // undefined, потому что (x = 1) не вычисляется

//Если бы первый аргумент имел значение false, то || приступил бы к вычислению второго и выполнил операцию присваивания:

// let x;
// false || (x = 1);
// alert(x); // 1


// result = a && b; И
// В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false
//Когда все значения верны, возвращается последнее
//alert( 1 && 2 && 3 ); // 3

//Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.
//Таким образом, код a && b || c && d по существу такой же, как если бы выражения && были в круглых скобках: (a && b) || (c && d).


// let hour = 12;
// let minute = 30;

// if (hour == 12 && minute == 30) {
//   alert( 'The time is 12:30' );
// }


//result = !value; !НЕ

// Сначала приводит аргумент к логическому типу true/false.
// Затем возвращает противоположное значение.

// alert( !true ); // false
// alert( !0 ); // true


let ge = 12
let tr = 'gerg'

alert(ge + tr )